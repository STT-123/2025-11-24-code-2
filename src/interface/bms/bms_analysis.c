#include <arpa/inet.h> // htonl
#include <byteswap.h>  // bswap_16, bswap_32
#include "bms_analysis.h"
#include "interface/modbus/modbus_defines.h"
#include "interface/bms/bms_simulink/CANSendFcn.h"
#include "interface/bms/bms_simulink/CANFDRcvFcn_BCU.h"
#include "interface/bms/bms_simulink/CANRcvFcn_BMU.h"
#include "interface/log/log.h"
#include <stdatomic.h>
extern CAN_FD_MESSAGE_BUS CANSendMsg;    
static atomic_int log_interrupt_count = ATOMIC_VAR_INIT(0);  
void my_modbus_set_float_badc(float f, uint16_t *dest)
{
    uint32_t i;

    memcpy(&i, &f, sizeof(uint32_t));
    i = htonl(i);
    dest[0] = (uint16_t)bswap_16(i >> 16);
    dest[1] = (uint16_t)bswap_16(i & 0xFFFF);
}

/**
 * 将标准 can_frame 转换为 CAN_FD_MESSAGE_BUS
 * 由于Matlab的输入只有一个CAN_FD_MESSAGE_BUS类型的，所以只能这么转换
 */
void ConvertCANToBus(const struct can_frame *frame, CAN_FD_MESSAGE_BUS *msg)
{
    if (!frame || !msg){
        LOG("[BMS] eeee Raw can_id      : 0x%08lX\n", frame->can_id);
        return;
    }

    msg->ID = frame->can_id & CAN_EFF_MASK; // 取 29 位
    msg->Extended = 1;
    msg->Remote = 0;
    msg->Error = 0;
    msg->Length = frame->can_dlc;
    
    msg->Timestamp = 0;
    memcpy(msg->Data, frame->data, frame->can_dlc);
}

void ConvertCANFDToBus(struct canfd_frame *frame, CAN_FD_MESSAGE_BUS *msg)
{
    if (!frame || !msg)
        return;
    
    msg->ID = frame->can_id & CAN_EFF_MASK;// 提取 ID，去掉扩展/远程/错误标志位
    msg->ProtocolMode = 1; // 1 表示 CAN FD
    msg->Extended = 1;
    msg->Remote = 0;
    msg->Error = 0;
    msg->BRS = 0;
    msg->ESI = 0;
    msg->Length = frame->len;
    msg->DLC = frame->len;
    msg->Reserved = 0;
    msg->Timestamp = 0;
    memcpy(msg->Data, frame->data, frame->len);
}

void ConvertBusToCANFD(const CAN_FD_MESSAGE_BUS *msg, struct canfd_frame *frame)
{
    if (!msg || !frame)
        return;

    // 清空目标结构体
    memset(frame, 0, sizeof(*frame));

    // 设置 CAN ID 和标志位
    frame->can_id = msg->ID;
    // 添加扩展帧标志（EFF）
    if (msg->Extended)
    {
        frame->can_id |= CAN_EFF_FLAG;
    }

    // 添加远程帧标志（RTR）
    if (msg->Remote)
    {
        frame->can_id |= CAN_RTR_FLAG;
    }

    // 添加错误帧标志（ERR）
    if (msg->Error)
    {
        frame->can_id |= CAN_ERR_FLAG;
    }

    // 设置数据长度
    frame->len = msg->Length;// 设置 CAN FD 特有标志（BRS 和 ESI）
    
    frame->flags = 0;
    if (msg->BRS)
    {
        frame->flags |= CANFD_BRS;
    }
    if (msg->ESI)
    {
        frame->flags |= CANFD_ESI;// canfd 的错误帧状态
    }
    memcpy(frame->data, msg->Data, msg->Length);

}

void Convert_CAN_MESSAGE_to_can_frame(const CAN_MESSAGE *msg, struct can_frame *frame)
{

    memset(frame, 0, sizeof(struct can_frame));

    frame->can_id = msg->ID;

    if (msg->Extended)
    {
        frame->can_id |= CAN_EFF_FLAG;
    }

    if (msg->Remote)
    {
        frame->can_id |= CAN_RTR_FLAG;
    }

    if (msg->Error)
    {
        frame->can_id |= CAN_ERR_FLAG;
    }

    if (msg->Length <= 8)
    {
        frame->can_dlc = msg->Length;
    }
    else
    {
        frame->can_dlc = 8;
    }

    memcpy(frame->data, msg->Data, frame->can_dlc);
}

void Convert_canfd_frame_to_CAN_MESSAGE(const struct canfd_frame *frame, CAN_MESSAGE *msg)
{
    memset(msg, 0, sizeof(CAN_MESSAGE));
    msg->ID = frame->can_id & CAN_EFF_MASK;// 提取 CAN ID

    msg->Extended = 1;
    msg->Remote = 0;
    msg->Error = 0;

    msg->Length = (frame->len > 8) ? 8 : frame->len;

    msg->Timestamp = 0;

    // 拷贝数据
    memcpy(msg->Data, frame->data, msg->Length);
}

void Convert_canfd_frame_to_can_fram(const struct canfd_frame *frame, struct can_frame *msg)
{
    memset(msg, 0, sizeof(struct can_frame));
    msg->can_id = frame->can_id & CAN_EFF_MASK;// 提取 CAN ID

    msg->__res0 = 0;
    msg->__pad = 0;
    msg->__res1 = 0;

    msg->can_dlc = (frame->len > 8) ? 8 : frame->len;

    // 拷贝数据
    memcpy(msg->data, frame->data, msg->can_dlc);
}

void Convert_can_frame_to_CAN_MESSAGE(const struct can_frame *frame, CAN_MESSAGE *msg)
{
    memset(msg, 0, sizeof(CAN_MESSAGE)); 
    msg->ID = frame->can_id & CAN_EFF_MASK;// 提取 ID，去掉扩展/远程/错误标志位

    msg->Extended = 1;
    msg->Remote = 0;
    msg->Error = 0;

    // 数据长度控制在 0~8 之间
    if (frame->can_dlc <= 8)
    {
        msg->Length = frame->can_dlc;
    }
    else
    {
        msg->Length = 8;
    }

    memcpy(msg->Data, frame->data, frame->can_dlc);

#ifndef TIMESTAMP_NOT_REQUIRED
    // 如果定义了时间戳字段，初始化为 0.0（无实际来源）
    msg->Timestamp = 0.0;
#endif
}



void Set_BCU_Voltage(float voltage)
{
    uint16_t temp[2] = {0};
    // printf("voltage: %f\n", voltage);
    float adjusted_voltage = voltage;
    my_modbus_set_float_badc(adjusted_voltage, temp);
    set_modbus_reg_val(MDBUS_ADDR_DC_VOL, temp[0]);
    set_modbus_reg_val(MDBUS_ADDR_DC_VOL + 1, temp[1]);
}

void Set_BCU_Current(float current)
{
    uint16_t temp[2] = {0};
    // printf("current: %f\n", current);
    float adjusted_current = current;
    my_modbus_set_float_badc(adjusted_current, temp);
    set_modbus_reg_val(MDBUS_ADDR_DC_CUR, temp[0]);
    set_modbus_reg_val(MDBUS_ADDR_DC_CUR + 1, temp[1]);
}

void Set_BCU_Power(int32_t power_watt)
{
    // float power_kw = (float)power_watt / 1000.0f;
    // printf("power_watt: %f\n", power_watt);
    uint16_t temp[2] = {0};
    my_modbus_set_float_badc(power_watt, temp);
    set_modbus_reg_val(MDBUS_ADDR_DC_POW, temp[0]);
    set_modbus_reg_val(MDBUS_ADDR_DC_POW + 1, temp[1]);
}

void Set_BCU_PositiveEnergy(float energy_wh)
{
    uint32_t energy_mwh = energy_wh * 1000;
    // printf("energy_mwh: %d\n", energy_mwh);
    set_modbus_reg_val(MDBUS_ADDR_P_ENERGY, energy_mwh & 0xFFFF);
    set_modbus_reg_val(MDBUS_ADDR_P_ENERGY + 1, energy_mwh >> 16);
}

void Set_BCU_NegativeEnergy(float energy_wh)
{
    uint32_t energy_mwh = energy_wh * 1000;
    // printf("energy_mwh: %d\n", energy_mwh);
    set_modbus_reg_val(MDBUS_ADDR_N_ENERGY, energy_mwh & 0xFFFF);
    set_modbus_reg_val(MDBUS_ADDR_N_ENERGY + 1, energy_mwh >> 16);
}

void set_OTA_XCPConnect(uint8_T value) { OTA_XCPConnect = value; }
uint8_T get_OTA_XCPConnect(void) { return OTA_XCPConnect; }

void set_TCU_ACMuteSet(uint8_T value) { TCU_ACMuteSet = value; }
uint8_T get_TCU_ACMuteSet(void) { return TCU_ACMuteSet; }

void set_TCU_BCUEINSet(uint32_T value) { TCU_BCUEINSet = value; }
uint32_T get_TCU_BCUEINSet(void) { return TCU_BCUEINSet; }

void set_TCU_ChargerWorkSts(uint8_T value) { TCU_ChargerWorkSts = value; }
uint8_T get_TCU_ChargerWorkSts(void) { return TCU_ChargerWorkSts; }


void set_TCU_ECOMode(uint8_T value) { TCU_ECOMode = value; }
uint8_T get_TCU_ECOMode(void) { return TCU_ECOMode; }


void set_TCU_LifeCounter(uint8_T value) { TCU_LifeCounter = value; }
uint8_T get_TCU_LifeCounter(void) { return TCU_LifeCounter; }

void set_TCU_PowerUpCmd(uint8_T value) { TCU_PowerUpCmd = value; }
uint8_T get_TCU_PowerUpCmd(void) { return TCU_PowerUpCmd; }

void set_TCU_TimeCalFlg(uint8_T value) { TCU_TimeCalFlg = value; }
uint8_T get_TCU_TimeCalFlg(void) { return TCU_TimeCalFlg; }

void set_TCU_TimeDay(uint8_T value) { TCU_TimeDay = value; }
uint8_T get_TCU_TimeDay(void) { return TCU_TimeDay; }

void set_TCU_TimeHour(uint8_T value) { TCU_TimeHour = value; }
uint8_T get_TCU_TimeHour(void) { return TCU_TimeHour; }

void set_TCU_TimeMinute(uint8_T value) { TCU_TimeMinute = value; }
uint8_T get_TCU_TimeMinute(void) { return TCU_TimeMinute; }

void set_TCU_TimeMonth(uint8_T value) { TCU_TimeMonth = value; }
uint8_T get_TCU_TimeMonth(void) { return TCU_TimeMonth; }

void set_TCU_TimeSecond(uint8_T value) { TCU_TimeSecond = value; }
uint8_T get_TCU_TimeSecond(void) { return TCU_TimeSecond; }

void set_TCU_TimeWeek(uint8_T value) { TCU_TimeWeek = value; }
uint8_T get_TCU_TimeWeek(void) { return TCU_TimeWeek; }

void set_TCU_TimeYear(uint8_T value) { TCU_TimeYear = value; }
uint8_T get_TCU_TimeYear(void) { return TCU_TimeYear; }

void set_TCU_FcnStopSet(uint8_T value) { TCU_FcnStopSet = value; }
uint8_T get_TCU_FcnStopSet(void) { return TCU_FcnStopSet; }

void set_TCU_HighVoltType(uint8_T value) { TCU_HighVoltType = value; }
uint8_T get_TCU_HighVoltType(void) { return TCU_HighVoltType; }

void set_TCU_HighVoltValue(uint16_T value) { TCU_HighVoltValue = value; }
uint16_T get_TCU_HighVoltValue(void) { return TCU_HighVoltValue; }


uint8_T get_BCU_TimeYearValue(void) { return BCU_TimeYear; }
uint8_T get_BCU_TimeMonthValue(void) { return BCU_TimeMonth; }
uint8_T get_BCU_TimeDayValue(void) { return BCU_TimeDay; }
uint8_T get_BCU_TimeHourValue(void) { return BCU_TimeHour; }
uint8_T get_BCU_TimeMinuteValue(void) { return BCU_TimeMinute; }
uint8_T get_BCU_TimeSencondValue(void) { return BCU_TimeSencond; }



uint32_T get_BCU_FaultInfoLv1Value(void) { return BCU_FaultInfoLv1; }
uint32_T get_BCU_FaultInfoLv2Value(void) { return BCU_FaultInfoLv2; }
uint32_T get_BCU_FaultInfoLv3Value(void) { return BCU_FaultInfoLv3; }
uint32_T get_BCU_FaultInfoLv4Value(void) { return BCU_FaultInfoLv4; }
uint16_T get_BCU_SOCValue(void) { return BCU_SOC; }
uint16_T get_BCU_SystemWorkModeValue(void) { return BCU_SystemWorkMode; }


uint16_T *get_BCU_usSingleBatVal(void) {
    return (uint16_T *)&usSingleBatVal[0];
}
uint16_T *get_BCU_usSingleBatTemp(void) {
    return (uint16_T *)&usSingleBatTemp[0];
}

uint16_T *get_BMU_DAq_version(void){
    return (uint16_T *)&DAq_version[0];
}

uint32_T get_BMU_DAqX_FaultCode1_at(int idx) {
    return DAqX_FaultCode1[idx];
}
uint32_T get_BMU_DAqX_FaultCode2_at(int idx) {
    return DAqX_FaultCode2[idx];
}

int32_T get_BCU_iDcPower(void) {

    return (int)BCU_RealtimePower;  /* 返回 */
}
unsigned long long get_BCU_ullPosEleQuantity(void) {

    return (unsigned long long)BCU_EngryAccumulateDisChrg;  /* 返回 */
}
unsigned long long get_BCU_ullNegEleQuantity(void) {
    return (unsigned long long)BCU_EngryAccumulateChrg;  /* 返回 */
}
uint16_T get_BCU_usAirState(void) {
    return Chiller_ModeFb;  /* 返回 */
}
uint16_T get_BCU_usAirPumpState(void) {
    return Chiller_PumpStatus;  /* 返回 */
}
uint16_T get_BCU_usAirCompressorSta(void) {
    return Chiller_CompressorStatus;  /* 返回 */
}
uint16_T get_BCU_uiAirErrorfaultCode(void){
    return Chiller_Fault;  /* xxxxxxxxxxx 待定*/
}

uint16_T get_usBmuH2MaxConcentration(){
    return BCU_FasH2MaxValue;  /* xxxxxxxxxxx 待定*/
}
uint16_T get_usBmuCOMaxConcentration(){
    return BCU_FasCOMaxValue;  /* xxxxxxxxxxx 待定*/
}
uint16_T get_usBmuPressureMax(){
    return BCU_FasPressMaxValue;  /* xxxxxxxxxxx 待定*/
}
uint16_T get_usBmuLightMax(){
    return BCU_FasLightMaxValue;  /* xxxxxxxxxxx 待定*/
}
uint16_T get_usBmuH2MaxIndex(){
    return BCU_FasLightMaxValue;  /* xxxxxxxxxxx 待定*/
}
uint16_T get_usBmuCOMaxIndex(){
    return BCU_FasCOMaxIdx;  /* xxxxxxxxxxx 待定*/
}
uint16_T get_usBmuPressureMaxIndex(){
    return BCU_FasPressMaxIdx;  /* xxxxxxxxxxx 待定*/
}

uint16_T get_usBmuLightMaxIndex(){
    return BCU_FasLightMaxIdx;  /* xxxxxxxxxxx 待定*/
}

uint16_T get_usAirEnergyMode(){
    uint16_t value = 0;  // 分配实际内存
    get_modbus_reg_val(MDBUS_ENESAV_STA, &value);
    return value;  /* xxxxxxxxxxx 待定*/
}

uint16_T get_usAirInletPressure(){
    return Chiller_InletPressure;  /* xxxxxxxxxxx 待定*/
}

uint16_T get_usAirCoolSetTemp(){
    return ThermCtrl_ACWarmGoal;
}


uint16_T get_usAirOutWaterTemp(){
    return Chiller_TempOutlet;
}

uint16_T  get_usAirReturnWaterTemp(){
    return Chiller_TempInlet;
}


uint16_T get_usBatMaxVoltCellIndex(){
    return BCU_VoltMaxIdx;
}
uint16_T get_usBatMinVoltCellIndex(){
    return BCU_VoltMinIdx;
}
uint16_T  get_usBatMaxTempCellIndex(){
    return BCU_TempMaxIdx;
}
uint16_T  get_usBatMinTempCellIndex(){
    return BCU_TempMinIdx;
}

uint16_T get_usBatCellVoltMax(){
    return BCU_VoltMaxCellValue;
}
uint16_T get_usBatCellVoltMin(){
    return BCU_VoltMinCellValue;
}

uint16_T get_usBatCellTempMax(){
    return BCU_TempMaxValue;
}
uint16_T get_usBatCellTempMin(){
    return BCU_VoltMinCellValue;
}

void Log_TCU_Data(void)
{
    char data_str[256] = {0}; // 64 字节 → 最多 "XX " * 64 + '\0' ≈ 192 字节
    int offset = 0;

    for (int i = 0; i < 64; i++) {
        offset += snprintf(data_str + offset, sizeof(data_str) - offset,
                          "%02X%s", CANSendMsg.Data[i], (i < 64 - 1) ? " " : "");
    }

    LOG("[RECORD] TCU_Data : %s\r", data_str);
    atomic_fetch_add(&log_interrupt_count, 10); // ✅ 原子加10
}

void Log_Bcu_Data(const CAN_FD_MESSAGE *msg)
{
	unsigned char log_flag = 0;
	static unsigned int BCU_FaultInfoLv1_LAST = 0;
	static unsigned int BCU_FaultInfoLv2_LAST = 0;
	static unsigned int BCU_FaultInfoLv3_LAST = 0;
	static unsigned int BCU_FaultInfoLv4_LAST = 0;
	static unsigned short BCU_SystemWorkMode_LAST = 0;

	static unsigned int BCU_AirState_LAST = 0;
	static unsigned int BCU_AirErrorfaultCode_LAST = 0;

    if (!msg) return;

    // if(msg->ID == 0x18FFC13A){
    //     if (BCU_AirState_LAST != get_BCU_usAirState()){
    //         log_flag = 1;
    //         LOG("[RECORD] AirState: %d -> %d \r",BCU_AirState_LAST,get_BCU_usAirState());
    //         BCU_AirState_LAST = get_BCU_usAirState();
    //     }
    //     if(BCU_AirErrorfaultCode_LAST != get_BCU_uiAirErrorfaultCode()){
    //         log_flag = 1;
    //         LOG("[RECORD] AirErrorfaultCode: [0x%x] -> [0x%x] \r",BCU_AirErrorfaultCode_LAST,get_BCU_uiAirErrorfaultCode());
    //         BCU_AirErrorfaultCode_LAST = get_BCU_uiAirErrorfaultCode();
    //     }

    //     if (log_flag == 1){
    //         char data_str[100] = {0};
    //         int offset = 0;
            
    //         for (int i = 0; i < 8; i++) {
    //             offset += snprintf(data_str + offset, sizeof(data_str) - offset, 
    //                             "%02X%s", msg->Data[i], (i < 8) ? " " : "");
    //         }
    //         LOG("[RECORD] BCU_Air_Data: msg.ID=0x%X, CAN_Data = %s\r", msg->ID, data_str);
    //     }
    //     return;
    // }

    if(msg->ID == 0x180110E4){
        if (BCU_SystemWorkMode_LAST != get_BCU_SystemWorkModeValue()){
            log_flag = 1;
            LOG("[RECORD] SystemWorkMode: %d -> %d \r",BCU_SystemWorkMode_LAST,get_BCU_SystemWorkModeValue());
            BCU_SystemWorkMode_LAST = get_BCU_SystemWorkModeValue();
        }

        if (BCU_FaultInfoLv1_LAST != get_BCU_FaultInfoLv1Value()){
            log_flag = 1;
            LOG("[RECORD] FaultInfoLv1: [0x%x] -> [0x%x] \r",BCU_FaultInfoLv1_LAST,get_BCU_FaultInfoLv1Value());
            BCU_FaultInfoLv1_LAST = get_BCU_FaultInfoLv1Value();
        }

        if (BCU_FaultInfoLv2_LAST != get_BCU_FaultInfoLv2Value()){
            log_flag = 1;
            LOG("[RECORD] FaultInfoLv2: [0x%x] -> [0x%x] \r",BCU_FaultInfoLv2_LAST,get_BCU_FaultInfoLv2Value());
            BCU_FaultInfoLv2_LAST = get_BCU_FaultInfoLv2Value();
        }

        if (BCU_FaultInfoLv3_LAST != get_BCU_FaultInfoLv3Value()){
            log_flag = 1;
            LOG("[RECORD] FaultInfoLv3: [0x%x] -> [0x%x] \r",BCU_FaultInfoLv3_LAST,get_BCU_FaultInfoLv3Value());
            BCU_FaultInfoLv3_LAST = get_BCU_FaultInfoLv3Value();
        }

        if (BCU_FaultInfoLv4_LAST != get_BCU_FaultInfoLv4Value()){
            log_flag = 1;
            LOG("[RECORD] FaultInfoLv4: [0x%x] -> [0x%x] \r",BCU_FaultInfoLv4_LAST,get_BCU_FaultInfoLv4Value());
            BCU_FaultInfoLv4_LAST = get_BCU_FaultInfoLv4Value();
        }

        // 2. 检查是否需要强制打印（仅针对此 ID）
        int should_force_log = 0;
        int current = atomic_load(&log_interrupt_count);
        if (current > 0) {
            int prev = atomic_fetch_sub(&log_interrupt_count, 1);
            if (prev > 0) {
                should_force_log = 1;
                // printf("force log 0x180110E4\r\n"); // 调试用
            } else {
                // 补偿：其他线程已减到0，我们加回来
                atomic_fetch_add(&log_interrupt_count, 1);
            }
        }

        if (log_flag || should_force_log) {

            char data_str[200] = {0};
            int offset = 0;
            
            for (int i = 0; i < 64; i++) {
                offset += snprintf(data_str + offset, sizeof(data_str) - offset, 
                                "%02X%s", msg->Data[i], (i < 63) ? " " : "");
            }
            LOG("[RECORD] BCU_Data: msg.ID=%X, CAN_Data = %s\r", msg->ID, data_str);
        }
    }
}